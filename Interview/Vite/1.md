# Vite

## Vite 的构建原理

> 三大原理：快速的冷启动、即时的模块热更新、真正的按需加载
> 两个关键点：ES 模块 + 自己专门研发的开发服务器

### 快速的冷启动

> No Bundle + esbuild 预构建

传统的 webpack 会把所有的依赖构建完成才会启动。而 vite 利用浏览器对 ESM 的支持，做到真正的按需构建。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件，本质上实现了动态加载

### 即使的热更新机制

1. 与 webpack 的区别
   Webpack: 重新编译，请求变更后模块的代码，客户端重新加载
   Vite: 请求变更的模块，再重新加载
2. vite 更新机制
   1. 创建一个 websocket 服务端和 client 文件，启动服务
   2. 通过 chokidar 监听文件变更
   3. 当代码变更后，服务端进行判断并推送到客户端
   4. 客户端根据推送的信息执行不同操作的更新

### 真正的按需加载

## 为什么 Vite 比 webpack 快

### 运行原理

- webpack
  是先打包在进行编译的，也就是 webpack 会根据提供的 entry 入口，把所以得依赖模块都打包成一个文件，这样就会导致项目体积越大，打包东西越多，启动时间越长
- vite
  vite 不会对整个项目进行打包，而是在请求某个模块时实时编译的，按需加载特定模块。这也导致 vite 启动会比 webpack 项目更快，但是在切换不同路由时，vite 因为还需要编译打包，会出现卡顿的问题，也就是把整体打包耗时分摊成按需的了。

### 构建方式

- webpack
  webpack 基于 Node.js 构建的
- vite
  Vite 是基于 esbuild 构建的，而 esbuild 是基于 Go 语言的，Go 语言的构建速度比 node 更快 10-100 倍。

### 热更新机制

1. vite 使用了`预构建`依赖，vite 将项目分成了`依赖和源码`两部分，通常 vite 在初始预构建依赖后，后续就不会在实时更新了
2. vite 使用了 HTTP 的缓存策略，针对`源码模块`（我们自己写的代码）做了协商缓存处理，针对`依赖模块`（第三方库）做了强缓存处理，这样我们项目的访问的速度也就更快了。

#### 如何强制更新缓存

1. 使用 --force 启动开发服务器
2. 直接删掉 node_modules/.vite/ 文件夹

## 生产环境下为何不用 ESBuild 打包？

尽管 esbuild 的构建速度非常快，但是 esbuild 对很多 vite 的插件并不兼容，所以还是采用了生态基建更好的 rollup

## vite 对比其他打包工具有什么优势缺点？

### 优点

- Vite 内置了很多 loader 和配置，让开发者可以零配置跑起来一个项目，而 webpack 则是需要写很多复杂的配置
- 高效的构建速度和打包速度更快，vite 不需要完整打包项目才启动，而是按需加载对应模块。
- 热更新机制采用了预加载和缓存策略，让热更新机制也更加快速响应
- 丰富的插件生态，让开发者自由选择

### 缺点

- 浏览器兼容性，由于使用了 ES Moudles 和 HTTP2，对一些旧浏览器并不支持
- 生态系统，相比于 webpack 而言生态机制还是没有很丰富
- 性能问题，虽然 Vite 在开发模式下提供了快速的加载体验，但在大型项目中，它可能会遇到性能问题，尤其是在处理大量模块和依赖时。
- 开发环境下首屏加载变慢。由于 unbundle 机制，Vite 首屏期间需要额外做其它工作。
