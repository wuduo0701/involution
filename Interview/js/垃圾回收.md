# 垃圾回收

> JS 引擎自动检测哪些对象不再被引用，并释放这些对象占用的内存

## 内存泄漏的常见原因

### 全局变量

> 创建全局变量时，可以从代码中的任何位置访问它，这使得很难确定何时不再需要它

1. 尽量在块级作用域中创建变量
2. 用函数进行包裹

### 事件监听器

定义了事件监听器的使用，在不用的时候需要及时消耗

### 闭包

> 导致一些不再需要的变量仍然被引用。

```js
function createClosure() {
  let largeArray = new Array(1000000)
  return function () {
    console.log(largeArray.length)
  }
}
```

## 垃圾回收策略

### 标记清除法

1. 标记阶段：
   从根对象（如全局对象和当前执行上下文）开始，递归地遍历所有可达对象，并将其标记为活动对象。
   任何没有被标记的对象都被认为是不可达的，即不再需要的。
2. 清除阶段：
   清除阶段会遍历内存中所有对象，释放那些没有被标记的对象所占用的内存。

### 引用计数法

每个对象都有一个引用计数器，当对象被引用时，计数器加一；当引用被移除时，计数器减一。
当计数器为零时，说明该对象不再被引用，可以被回收。

- 问题
  如果两个对象互相引用。会导致循环引用，无法解决

## JS 里的垃圾回收机制

> JS 里的数据存储分为栈存储和堆存储，两者采用的垃圾回收机制也是不同的

### 栈的垃圾回收机制

通过移动 ESP 指针(记录当前执行状态的指针)实现垃圾回收
当变量不在使用，栈会自动弹出，不会造成泄漏

### 堆的垃圾回收机制

1. V8 中会把堆分为新生代（短生命周期）和老生代（长生命周期）两个区域
2. 内存比较小，只有 32M
3. 新生代由副垃圾回收器负责，老生代由主垃圾回收器负责回收
4. 新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中
5. 新生代 `Scavenge 算法`；老生代对象采用 `三色标记算法`。
   1. 新生代分一半对象区域，一半是空闲区域。
      1. 如达到 GC 条件（对象区域满了）后，对对象区域的垃圾做标记
      2. 标记完成后把存活的对象复制到空闲区域中，并且有序化
      3. 完成复制后，反转对象区域与空闲区域。**（相当于把活跃对象都处理到空闲区域，把对象区域空闲下来，循环往复）**
   2. 老生代- `三色标记算法` 和 `标记压缩算法`
      1. 根对象标记为灰色。从根元素深度递归，能到达的就是活跃对象标记为黑色；不能到达的就是垃圾，标记为白色；遇到根对象，标记为灰色，并加入待处理队列，等待递归处理
      2. 清除白色标记的对象
      3. 【标记压缩算法】如不连续的内存超过限制后，需要进行内存整理。启动压缩：压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存

## 垃圾回收器的优化

### 问题

1. JS 是单线程，在垃圾回收时会阻塞 JavaScript 脚本的执行

### 优化

1. 并行回收。
   使用多线程技术，在后台并行或并发地执行垃圾回收操作
2. 增量回收
   将标记工作把垃圾回收工作分解为更小的块
3. 分代垃圾回收
   即堆的垃圾回收机制
