# 执行上下文和执行栈

## 执行上下文

> JavaScript 代码被解析和执行时所在环境的抽象概念

1. 执行上下文共分三种，分别为全局执行上下文（window，js 程序执行即有）、函数执行上下文（函数被调用就有）、eval 执行上下文。
   ![alt text](/assets/images/js/image2.png)
2. 执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段
   1. 创建阶段
      1. 确定 this 的值，也被称为 This Binding
      2. 创建词法环境（确定声明了哪些函数和变量，以及函数和变量如何引用和访问）
         1. 环境类型
            1. 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null，有一个全局对象，this 的值指向这个全局对象
            2. 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境
         2. 环境的组成
            1. 环境记录
               1. 变量函数声明
            2. 外部环境引用。
               1. 指向外部词法环境的引用
               2. 它形成了一个链条，称为作用域链
      3. 创建变量环境（即词法作用域。分三种：全局作用域、函数作用域、块级作用域）
         1. 区别与上面的是有个块级作用域，即 `let` 和 `const` 创建的变量。这两在创建的时候并不会被默认赋值，但`var`创建的变量会在创建的时候默认赋值 undefined，这就是变量提升的实际原因。且`var`声明的变量不会创建块级作用域，默认是在全局作用域
         2.
   2. 执行阶段
      1. 执行变量赋值、代码执行
      2. 如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值
   3. 回收阶段
      1. 执行上下文出栈等待虚拟机回收执行上下文

## 执行栈

总结：

1. 也叫调用栈，具有先进后出的性质，用于存储在代码执行期间创建的所有执行上下文
2. 当 js 引擎开始执行第一行脚本代码的时候，就会创建一个全局执行上下文然后将它压到执行栈中。每当碰到一个函数，就会创建一个函数执行上下文，并将其压入栈中
3. 当上下文读取完毕后，引擎会执行位于栈顶的上下文，当上下文执行完毕后，对应的执行上下文就会被弹出。直至最后一个上下文执行完毕
   ![alt text](/assets/images/js/image3.png)

## 作用域

> 也就是上面所说的`执行上下文`中的`变量环境`。分三种：全局作用域、函数作用域、块级作用域

- 作用域提升
  > 是 js 编译时的一个行为，当代码被编译时，js 引擎会把所有变量和函数都提升到当前作用域顶部。就会导致变量在声明前报错也不会报错

## 作用域链

> 当 js 引擎使用一个变量时，会先在当前作用域时查找，如未找到，会继续查找上层作用域，直至找到作用域顶层。如还未找到，就会报错（严格模式）

![alt text](/assets/images/js/image4.png)
