# 微前端技术原理

## 为什么要做微前端，为什么不使用 Iframe

### Iframe 的弊端

- url 不同步
  浏览器会导致 iframe 中的 url 丢失，前进后退按钮无法使用。比如一个页面中嵌入另一个系统，这个系统可以设计路由跳转的，那么此时点击路由跳转，在点击刷新按钮的话，不会记住之前得路由
- UI 不同步。
  这个很好理解，Iframe 是硬隔离，css 直接完全隔离的。最明显的效果就是弹窗或者侧滑窗，点击 iframe 中的弹窗，弹窗的遮罩不会影响到主应用
- 全局上下文完全隔离，内存变量不共享。如 cookie 信息、sessionStorage、localStorage 信息都不共享
  Iframe 是硬隔离，js 也是完全隔离的。如一些全局变量等、甚至 cookie、sessionStorage、localStorage 也是完全隔离的，他们会另起一个 url - storage 的 map 结构进行存储
- 加载慢、浪费资源
  iframe 每次加载都需要重新一次加载上下文、资源加载的过程，类似进行刷新浏览器，会涉及大幅的资源和内存消耗。

**Iframe 无法解决的问题：** UI 不同步、全局上下文完全隔离。这两点是选择微前端的关键

### 微前端的优势

- 模块开发
  可以帮一个巨石应用拆解成不同的微小应用，每个应用负责不同的模块，独立开发，独立部署，提高代码开发效率
- 技术栈无关
  每个微小应用可以选用不同的技术栈开发，不在受一个应用只能由一个技术限制
- 独立部署和升级
  每个微应用程序可以独立部署和升级，不会影响整个应用程序的运行，以提高部署和升级的效率和可靠性
- 团队自治性
  每个微应用可以由不同的团队进行负责，互不干扰
- 性能和用户体验
  拆分成多个小型应用程序，只加载必要的模块和组件
- 可复用性
  可以被不同的主应用程序复用

## 做微前端前怎么做技术选型的

答：

1. 当时主要参考了 4 个开源项目，一个是 qiankun、还有 singal spa、以及京东的 micro App、以及内部的 Jmodule（当时内部的行云团队开发，也就是我们的中台，但是他们没有做很好的开源）。当时做技术选型，我们是把库的稳定性以及社区是否活跃，遇到问题是否能有人快速解答等作为优先考虑的，所以就把 micro App 这个微前端框架给排除了，因为我们当时做架构升级的是 2023.2 月份，虽然 micro 社区活跃性已经够了，但是他们并未发布正式版，一直是 beta 版本，所以这个给排查了。
2. 所以只剩下 qiankun 和 singal spa。当时分别从成熟度、社区活跃度、能否满足当前需求（当时我们组内的系统 vue3、vue2、React 为代表的几种技术栈，所以当时乾坤已经能完成满足）、扩展性（能否满足后续系统的接入）等等，以及接入的开发量等等。最终衡量下来还是选择了当时已经很成熟的乾坤，以及在使用过程中又深入了解了乾坤做到的微前端原理

## 技术原理（乾坤）

`乾坤`运行原理

1. 步骤一：监听路由变化
   - 回答：监听浏览器底层的状态（`pushState`和`history.replaceState`。动态加载子应用
2. 步骤二：匹配子应用
3. 步骤三：加载子应用
   - 回答：
     1. JS Entry 的方式。就是将主子应用一起打包，类似 webpack 一样，把文件都打包在一起了，这样就完全丧失了未前端的优势。
     2. Qiankun 采用的是 HTML Entry 的方式。通过刚刚加载到的子应用的入口 url，拿到 html 文件，并从中容解析出 html、js、css 内容（各种正则匹配）。并把各种外链（<script></script>，<style></style>）去除，并通过 fetch 到对应的资源内联到 html 文档中。这样每次加载都去获取一次对应的资源，就能拿到最新的子应用资源。就主子应用就完全解耦了
4. 步骤四：渲染子应用
   - 回答：
   1. 渲染最重要的是做到如何把主子应用隔离开。然后又分了两种：js 隔离和 css 隔离
      1. js 隔离就是采用 js 沙箱做的
         1. 快照沙箱
         2. 单实例沙箱
         3. 多实例沙箱
      2. css 隔离
         1. 动态样式表。在第三步加载的时候，会把样式劫持出来内联到 html 文档中，卸载子应用还是会去除。这样不同子应用就能做到隔离，但是主子应用还是有影响
         2. 工程化手段。修改`antd`的修改前缀 prefix-cls="custom"

### 监听路由变化

- 步骤：

  1. 在主应用注册匹配子应用的注册规则，即匹配到这个路径就激活对应的子应用
  2. 而在浏览器路由切换还是 vue-router 的切换时，底层都是通过`history.pushState`和`history.replaceState`实现的。而
  3. 乾坤也是监听这些路由变化实现的，通过这样可以拿到执行前的 url 和执行后 url。从而激活和卸载子应用

- 弊端
  1. 因为乾坤和 vue-router 都是兼容浏览器路由变化的方法`history.pushState`和`history.replaceState`，所以在乾坤主应用中使用路由切换存在着会触发两次监听的问题，如果存在路由守卫中就会触发两次方法。 ---> `解决办法：通过判断前后路由跳转的路由是否一致，如果是一样的的，就return掉，从而减少一次执行`

### 加载

> 回答：
> JS Entry 的方式。就是将主子应用一起打包，类似 webpack 一样，把文件都打包在一起了，这样就完全丧失了未前端的优势。
> Qiankun 采用的是 HTML Entry 的方式。通过刚刚加载到的子应用的入口 url，拿到 html 文件，并从中容解析出 html、js、css 内容（各种正则匹配）。并把各种外链（<script></script>，<style></style>）去除，并通过 fetch 到对应的资源内联到 html 文档中。这样每次加载都去获取一次对应的资源，就能拿到最新的子应用资源。就主子应用就完全解耦了

1. 子应用的渲染一般有两种方案，一种是打包时主子应用一起打包，这样就会导致主子应用有高度耦合性，同时微前端优势之一（模块开发、独立部署等）就丧失了；另一种是运行时主应用加载子应用的资源，这样就能主、子应用的完全解耦。所以 qiank 采用的也是第二种的方式，但是用这个有一个弊端（JS Entry 问题），这个我也做了个研究。这也是 single spa 未解决的问题，因为乾坤是基于 single-spa 二次开发的。这也是为什么乾坤要求子应用必须暴露三种生命周期（bootstrap、mount、unmount），主要就是通过监听 url 的路由变化，来动态的加载卸载子应用的资源。
2. 刚刚提到的 `JS Entry` 是 single app 使用的，而乾坤很好的解决了这个问题，采用`HTML Entry`的方式。

- JS Entry
  > 就是需要把子应用的所有文件都打包进一个 js 文件中，并发布到服务器上，然后告诉主应用去这个地址拿微应用的资源
  - 弊端：
    1. 所有文件都打包进一个文件，一些常见的打包优化没了。如`按需加载优化`、`css 独立打包`等
    2. 子应用的每次打包更新，都会导致打包的 js 名称更改。这样导致主应用也有进行相应更新，然后发布部署，这微前端的优势之一独立部署就失去了。这样每次子应用发布一次，主应用也要相应的发布一次
- HTML Entry（import-html-entry）
  > 就是把子应用的 html 入口 url 告诉给主应用，主应用在加载到 html 字符串后，从中提取到相应的 js 和 css。每次加载子应用的时候才去读取子应用的 js 和 css 资源，这样就不管他是否有无更新，都能拿到最新的资源。做的就像 iframe 一样简单，只需要把 url 写进去，这样上面`JS Entry`的缺点就解决了。
  - 优点
    1. 无需关心子应用打包后的 js 文件名称变化的问题
    2. 子应用仍然可以自己配置打包配置，保留了各种打包优化。
  - 加载流程
    1. 通过 fetch 入口 url 中的 html 文档，即代码字符串内容
    2. 从上面的内容解析出 html、js、css 内容（各种正则匹配），并把各种外链（<script></script>，<style></style>）去除，并拿到相应的 scipt、style 数组
    3. 通过上面的 style、script 数组、fetch 到对应的资源。并把他们内联的方式内嵌到 html 文档中
    4. 这样每次加载都去获取一次对应的资源，就能拿到最新的子应用资源

### 隔离

- JS 隔离
  简单概括就是采用了`JS 沙箱`

  1. 它会为每一个子应用创建一个专属的 “window 对象”，但这个 window 对象并不是真正意义上的 window 对象，而是通过 `proxy` 劫持的对象
  2. 在执行子应用时，将刚刚劫持的‘window 对象’作为子应用脚本的全局变量，子应用对全局变量的读写操作都作用到这个 “window 对象”中。这样读写操作都没影响到真正的 window 对象，相当于一个 scope 作用域进行了隔离。

  - js 沙箱

    - snapshotSandBox(快照沙箱)

      > 在不支持 proxy 的浏览器中，会降级到快照沙箱

      - `原理：`
        在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。
      - `弊端：`
        1. 通过 for(prop in window){} 的方式来遍历 window 上的所有属性，消耗性能
        2. 还是会改变全局 window 的属性，如果同时运行多个微应用，就会出现状态混乱

    - 单实例沙箱 --> `优先使用`
      > 利用 proxy 的特性，劫持 window 对象。本质上是激活沙箱，还原子应用的 window 对象，卸载沙箱，还原主应用的 window 对象
      - `！！原理：`
        1. 沙箱定义了三个状态池 Map：
           1. 新增的变量（子应用运行期间往 window 挂载的变量，用于子应用卸载后还原）
           2. 更新的变量（子应用运行期间更新的外部 window 的变量，用于子应用卸载后还原）
           3. 记录全部新增和修改的变量（子应用初始化时的 window，用于下次加载还原子应用状态）
      - `弊端：`
        还是会改变全局 window 的属性，如果同时运行多个微应用，就会出现状态混乱
        只能隔离 window
    - 多实例的沙箱模式
      > 还是利用 proxy 劫持的特性，通过遍历复制 window 的副本到每个子应用上。这样在子应用操作 window 对象就是对副本的操作，不会影响到主应用的全局 window，而且各个子应用也互不干扰。
      - 优势
        1. 不存在状态的恢复了，所有变化都是对副本的操作
        2. 支持多个微应用间同时运行

- CSS 隔离
  > 样式隔离有三种（动态样式表、工程化手段、严格隔离模式 Shadow）
  - 动态样式表
    当挂载子应用时，乾坤会解析子应用的 css 全部挂载到 style 上。这样在子应用间切换时，不同应用的 css 也会进行挂载卸载，这样就保证不同的应用不同时存在。这样做到了基本的样式隔离
    - 弊端：
    1. 主应用和子应用、同时存在的不同子应用间还是会存在混用
  - 工程化手段
    - 如`antd`的修改前缀 prefix-cls="custom"
    - 约定 ben 模式
  - 严格隔离模式 Shadow
    存在兼容问题

### 通信

当主要启动 start 函数时，将基座的数据通过 props 传递下去。子应用能在 mounted 生命周期接收 props。同时提供了子应用修改主应用数据的方法。
