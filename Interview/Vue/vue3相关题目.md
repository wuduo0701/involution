# 题目

## vue3 比 vue2 有什么优势？

> 性能更好，打包体积更小，更好的 ts 支持，更好的代码组织，更好的逻辑抽离，更多的新功能

## vue3 性能提升

### 响应式系统

### diff 算法优化

> vue3 在 diff 算法中相比 vue2 增加了静态标记

关于这个静态标记，其作用是为了会发生变化的地方添加一个 flag 标记，下次发生变化的时候直接找该地方进行比较
标记静态节点的 p 标签在 diff 过程中则不会比较，把性能进一步提高

- 静态标记：
  Vue 3 会在编译阶段标记静态节点，这样在更新时可以跳过这些节点的 diff 过程，因为它们不会发生变化。

- Patch Flag：
  通过引入 Patch Flags，Vue 3 能够更精确地知道哪些部分需要更新。编译器在生成渲染函数时，会为动态属性添加标记，从而减少不必要的比较。

### 静态提升

```html
<div>
  <!-- 需提升 -->
  <div>foo</div>
  <!-- 需提升 -->
  <div>bar</div>
  <div>{{ dynamic }}</div>
</div>
```

没有必要在重新渲染时再次创建和比对它们。Vue 编译器自动地会提升这部分 vnode 创建函数到这个模板的渲染函数之外，并在每次渲染时都使用这份相同的 vnode，渲染器知道新旧 vnode 在这部分是完全相同的，所以会完全跳过对它们的差异比对。

### tree-shaking

> 是一种通过清除多余代码方式来优化项目打包体积的技术

1. 会把没有引入的包给移除掉，尽可能最大程度的减少打包后的体积
   ```js
   import { nextTick, observable } from 'vue'
   nextTick(() => {})
   ```
2. 减少程序执行时间（更快）
3. 便于将来对程序架构进行优化（更友好）

## script setup 是干啥的？

scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：

属性和方法无需返回，可以直接使用。
引入组件的时候，会自动注册，无需通过 components 手动注册。
使用 defineProps 接收父组件传递的值。
useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。
默认不会对外暴露任何属性，如果有需要可使用 defineExpose

## watch 和 watchEffect 的区别？

### watch

> 既要指明监视的数据源，也要指明监视的回调。

### watchEffect

> 是一个副作用函数，可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。

### 不同点

1. watch 指明监视的数据源；watchEffect 不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据
2. watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值
3. watch 运行的时候不会立即执行，值改变后才会执行。watchEffect 运行后可立即执行

## vue2 和 vue3 核心 diff 算法区别

1. Vue 2.x 使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟 DOM 树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。
2. Vue 3.x 使用了经过优化的单向遍历算法，也就是只扫描新虚拟 DOM 树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟 DOM 创建后，Vue 3 会缓存虚拟 DOM 节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3 还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成 HTML 字符串，大大提升了渲染性能。
   因此，总体来说，Vue 3 相对于 Vue 2 拥有更高效、更智能的 diff 算法，能够更好地避免不必要的操作，并提高了渲染性能
