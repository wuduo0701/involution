# 能介绍个你觉得写的最复杂的业务组件吗？

1. 多版本对比业务组件
   1. 业务复杂、数据结构复杂（多层嵌套、返回值类型不定、嵌套结构不定、嵌套数据不定、映射的值不定、如何做到逐行逐字对比）
   2. 多层嵌套情况（自定义多层动态嵌套结构、基础信息、调度信息）
   3. 每行数据类型不一致
   4. 数据映射（后端并不是返回中文，但是前端得显示中文对比）
   5. SQL 逐行对比，细化到每行
   6. 支持多个地方调用，通用化
   7. 是否存在差异、只显示差异部分如何做？
   8. 结合前端截图工具、图片上传服务
   9. 返回到 xbp 服务
   10. 返回给用户审批

# 小工具有哪些，能详细说说吗

1. 截图服务？
2. 实时看板监控小工具

# 团队什么原因基于选择 vue3 框架

1. 框架自身的
   1. vue3 框架性能相比于旧版本能提升很多。如 composition API、vite、diff 算法更新、treesharking 等等。能带来更快的开发效率
   2. 带来更多的特性。 Fragments 支持、Teleport 组件、setup 等等。能带来更好的开发体验
   3. 社区维护度。Vue 3 是最新版本，而且 vue2 vue 已经说明停止更新了。意味着 vue3 后面能带来长期的支持，避免框架被淘汰。
2. 生态。
   1. vue 的生态逐渐向 vue3 靠拢。后期团队有类似需求，而市面没有就得花更多时间自研。如 vite 等都能带来更好的体验
3. 用户
   1. 更快的性能带来更好的体验
   2. 更小的体积带来更快的渲染
4. 团队技术栈的扩展

# 如何比较框架更新带来的产出比。

1. 短期来看。框架升级会有更多的迁移以及学习成本
2. 长期收益。能为系统更多性能、更好的维护性和可扩展性

# 项目的性能优化

- 背景
  1. 京数通是采用的多页签的交互形式，用户打开多个标签后，然后相互切换后，能够快速复现之前的页面
  2. 但是到了子应用后，多页签效果就消失了，每次用户打开都有很长的时间 loading
- 目标
- 行动
- 成果
  1. 子应用也能无损切换
  2.

# 项目中遇到最难的事是啥

## 京数通的微前端架构改造，从调研、方案落地、实现

- 背景
  1. 当时 jst 系统正经历重构，在之前老系统中，也有系统接入到 jst。就是以 iframe 的形式。但是重构后组内对这部分子应用产生分歧（部分认为应该也重构，部分则认为应该保持不动）
  2. 基于这个背景（因为在之前我已经了解到微前端这项技术，并已经生产成熟了），我去调研了当时市面是主流的微前端方案（iframe、无界、micro-app），进行优劣势分析，并落地了 demo。并给组内做了详细的分析以及讨论，最终决定采用微前端，然后我去主导落地。
     1. 微前端与 iframe 的优劣势分析
     2. 介绍了微前端的方案及其成果展示。
     3. 业界成品展示
     4. 使用微前端能带来什么
        1. 考虑到重构成本
        2. iframe 的劣势
        3. 会带来什么影响
        4. 后续在接入子应用的代价
- 目标
  1.
- 行动
  1. 做了更详细的调研，和原理分析。最终采用了 Qiankun
  2. 然后我基于 Qiankun 做了一个基座主应用，并接入了组内的几个业务系统。
- 结果
  1. 完成了基座应用的开发，期间共接入了组内 4 个系统以及外部门多个系统。
  2. 使得用户量增加很多，并且粘性大大增加
  3. 后续新接入子应用 0 代码升级。

## 在落地组内子应用的时候，发现几个问题

- 背景
  1. 子应用的配置经常性修改，协作不便利，经常需要改动基座应用。如子应用的跨域配置、路由设置、入口资源。
  2. 其他组新接入想要子系统时，基座也需要增加配置，并且他们修改相关配置后，都需要我们协作上线
- 目标
  1. 期望做到平台化。后续新接入系统，有入口申请，并进行统一管理
  2. 配置化。子应用的配置进行配置化
- 行动
  1. 基于这个目标，然后我做了一个子应用管理后台，
  2. 接入子应用，只需在这个平台申请就行，并填入相关子应用配置（ID、接口设置、路由设置、入口等）
  3. 修改子应用配置，也是负责人在平台进行修改就行，我们只负责审核。
  4. 基座应用在启动时，动态注册子应用的配置
- 结果
  1. 节省了人力消耗、并
  2. 接入新系统或者配置，无需在修改代码上线。
  3. 并且可以做到子应用的版本控制

# 前端组件库的设计原则

1. 统一的设计原则。如 UI、排版、视觉、行为
2. 复用性。组件只是组件，不需要业务，尽可能的能服用
3. 配置化，提供足够多的配置
4. 方便测试
5. 详细的文档

# 实时看板-相关

## 性能优化

1. 增加服务器
2. 增量更新。只发送变化的数据，减少不必要的传输
3. 数据缓存。缓存一分钟的数据
4. 主动断开连接。
   1. SSE 除非用户主动断开，否则很难断开，超时多久无操作，自动断链
5. 限流。
6. 心跳机制。
   1. 服务器向客户端定期发送心跳消息，客户端收到后可以确认连接正常
7. 数据压缩

## 系统稳定性

1. 错误重试机制
2. 断开重试机制
3. 弱网检测，如网络不稳定，会提示给用户
4. 连接监控。SSE + ES 埋点机制
5. 实时监控服务器资源，及时扩展服务器容量
6. 数据延迟。
   1. 大屏时间是数据产出时间，一般是比真实时间晚 3 分钟。如在长，就会提示给用户，数据出现延迟，请谨慎使用

## 降级

1. 降级为短轮询机制
2. 静态 HTTP 请求

## 前端角度的性能优化

- 代码及其打包优化
  1. 资源压缩与合并，开启 gzip。
  2. 打包优化，开启 treesharking
  3. 懒加载技术
  4. CDN。有一些静态资源，使用 CDN
  5. 利用 HTTP 缓存策略
  6. 使用 HTTP2
- 渲染优化
  1. 异步加载脚本。防止阻塞
  2. 减少重绘和回流
  3. GPU 加速
- 监控分析

# 截图服务-相关优化

## Node 相关

1. html2canvas 优化
2. 限流策略
3. 异步手段，避免阻塞请求。
4. 缓存。判断数据有无更新，是否能用之前的截图。
5. 增加机器
6. 控制并发量。测试出系统可承接的最大负载
7. Kafka 技术。平衡负载的调用量

## 前端服务相关优化

- 渲染
  1. 懒加载。减少渲染负担
  2. 资源压缩。gzip
  3. treesharing
  4. 网络优化。使用 http2、缓存
  5. js 和 css 不要阻塞渲染
  6. 减少 dom 结构
- 截图
  1. 部分截图。其他支持在线预览
  2.

# 对项目的流程和技术有什么思考
