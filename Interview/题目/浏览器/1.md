# js 如何监听 dom 的变化

1. 事件冒泡：利用某些事件的冒泡特性，例如 input 事件可以监听输入框内容的变化。
2. MutationObserver
   ```js
   const observer = new MutationObserver((mutationsList, observer) => {
     for (const mutation of mutationsList) {
       if (mutation.type === 'attributes') {
         console.log(`属性 ${mutation.attributeName} 发生了变化`)
       }
       // 处理其他类型的变化
     }
   })
   const targetNode = document.getElementById('yourElementId')
   observer.observe(targetNode, { attributes: true })
   ```

# 回流和重绘

> 回流必定会发生重绘，重绘不一定会引发回流
> 回流的成本很高，尽量减少发生回流

1. 回流：会影响文档流的布局和绘制
   1. 页面首次渲染
   2. 改变字体大小
   3. 改变视窗大小
   4. 添加或者删除样式
   5. 读取某些元素（浏览器需要确保获取到的布局信息是最新的）
2. 重绘：会改变文档的外观。

# 一帧中浏览器做了哪些行为

> 如用户输入某某改变了页面样式

1. 执行宏任务
2. 执行所有微任务
3. 执行 requestAnimationFrame
4. 更新动画和样式。计算 DOM 样式的位置及其样式更新，JS 可以手动操作 DOM
5. 布局（回流）。重新计算页面的布局，更新 DOM 位置
6. 绘制（重绘）。更新 DOM 样式
7. 显示更新。

# 浏览器进程间的通信方式

1. 管道 pipe。半双工的通信方式，只能父子进程通信
2. 命名管道 FIFO。半双工的通信方式，运行没有亲缘之间进程通信
3. 消息队列
4. 共享存储
5. 信号量
6. 信号
7. 套接字 Socket

# Service worker??

# 进程和线程的区别

# 进程的生命周期

# 事件委托是怎么判断哪个子元素触发事件的

> 通过利用事件冒泡机制，会接受到这个事件对象。当接受对象匹配到了。`target.tagName === 'LI'`，就会得到触发

# 哪些资源加载会阻塞 dom 渲染，哪些会阻塞 dom 解析

1. 阻塞 dom 渲染
   1. css 加载
   2. js 加载
2. 阻塞 DOM 树的解析
   1. js 加载
3. 最好的方式
   1. CSS 资源需排在 JS 资源前面
   2. JS 应该放在 HTML 底部

# localStorage 安全

1. 持久化存储，除非用户主动清楚，所以不应该存储敏感信息
2. 受同源策略影响
3. 易受 XSS 攻击，需要安全手段防护
4. 明文存储，需要进行加密。
