# Vuex

1. pinia 和 vuex 有什么区别
   1. pinia 是基于 vue3 的特性开发的。使用了 composition API 来组织；vuex 使用 options API 开发
   2. Vuex 包含了四个部分：state、mutations、actions 和 getters。而 pinia 只有一个 store 实例
   3. pinia 是基于 vue 的响应式原理设计的
   4. pinia 更支持 ts。提供了更好的类型安全。vuex 相对更弱

# Vue-router

# vue

1. 写过自定义指令吗？具体的应用场景
   1. 类似于 v-model，v-show，v-if。是 vue 方便操作的系统指令。如常用的防抖（v-debounce）、复制。可以注册成自定义指令
   2. 对元素上添加特定行为，不同于 mixin
   3. 分两种注册模式，全局注册：`Vue.directive`,
      1. 全局注册
         ```js
         // 注册一个全局自定义指令 `v-focus`
         Vue.directive('focus', {
           // 当被绑定的元素插入到 DOM 中时……
           inserted(el, binding) {
             // 绑定的值是一个对象，包含函数和延迟时间
             const [fn, delay] = binding.value
             if (typeof fn !== 'function') {
               console.warn('Expect a function as the first argument')
               return
             }
             const debouncedFn = debounce(fn, delay)
             // 将防抖函数绑定到元素的事件监听器上
             el.addEventListener('click', debouncedFn)
           }
         })
         ```
      2. 局部注册
         ```js
         directives: {
            focus: {
               // 指令的定义
               inserted: function (el) {
                  el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
               }
            }
         }
         ```
2. vue 的 mixin 理解
   1. 本质其实就是一个 js 对象，它可以包含我们组件中任意功能选项，如 data、components、methods 、created、computed 等等
   2. 在日常的开发中，会遇到在不同的组件中需要用到一些相同或者相似的代码，这些代码的功能相对独立。这时候就可以通过 mixin 进行独立
   3. 分全局 mixin （vuex、组件库的样式）和局部 mixin
   4. 组件里的函数定义优先级会更高，重复会覆盖 mixin 中的
   5. 弊端：
      1. 命名冲突：如果多个 mixin 和组件本身定义了相同的选项（如方法、数据属性），可能会导致冲突或意外的覆盖。
      2. 当组件依赖多个 mixin 时，追踪属性会很麻烦，降低代码的可读性和可维护性
3. keep-alive
   1. keep-alive 在 vue 中用于实现组件的缓存，当组件切换时不会对当前组件进行卸载
   2. 支持的属性
      1. include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
      2. exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
      3. max - 数字。最多可以缓存多少组件实例。超出上限使用 LRU 的策略置换缓存数据。其作用就是使用 LRU 的策略防止缓存大量组件，占用大量内存。
   3. 采用的是 `LRU算法(最近最少使用)`
      1. 判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 key 在 keys 中的位置（移除 keys 中 key ，并放入 keys 数组的最后一位）
      2. 如果没有缓存，则缓存该实例，若 keys 的长度大于 max （缓存长度超过上限），则移除 keys[0] 缓存
   4. 缓存后如何获取数据？
      1. beforeRouteEnter
         每次组件渲染的时候，都会执行 beforeRouteEnter
      2. actived
         在 keep-alive 缓存的组件被激活的时候，都会执行 actived 钩子
4. Vue 项目中如何封装 axios
   1. 原因：随着项目的增大，每发起一次 axios 就需要设置请求时间、超时时间、代理地址等等。这种重复特别冗余
   2. 封装常用的请求方法，把公用的配置放进方法（如超时时间等），如不同，支持扩展。然后导出请求方法
   3. 添加请求拦截器。如日志需要，或者区分特殊的请求。比如（截图服务、需要特殊请求头的服务）
   4. 添加相应拦截器。与后端定义标准的协议状态码。如-100、403、503 等
5. vue 中更多形式的代码复用
   1. compistion APi
   2. Mixin
   3. 自定义指令
   4. 工具函数
   5. vuex
6. 如何实现一个 modal 组件
   1. 定义组件的目录结构及其组件内容
      1. 目录结构。主 vue 文件、入口文件、config.ts 配置文件、ts 类型文件
      2. 组件内容。由 Teleport 包裹，传送到 body。包含标题、内容、footer 区域。都可以由插槽替换
   2. 全局 modal 函数。
      1. 如何调用
         ```js
         $modal.show({
           title: '演示 jsx 语法',
           content() {
             return (
               <div
                 onClick={($event: Event) =>
                   console.log('clicked', $event.target)
                 }
               >
                 hello world ~
               </div>
             )
           }
         })
         ```
      2. 如何挂载
         1. Vue.prototype 挂载在 vue 原型链上
         2. vue3：app.config.globalProperties.$modal = modal
